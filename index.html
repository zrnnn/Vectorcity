<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VectorCity Topo Studio</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/lucide@latest"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --primary: #2563eb;
      --bg-app: #f8fafc;
      --text-main: #0f172a;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-app);
      color: var(--text-main);
    }

    h1, h2, .font-display { font-family: 'Space Grotesk', sans-serif; }

    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }

    .leaflet-control-attribution { display: none; }

    #viewfinder {
      position: absolute;
      box-shadow: 0 0 0 9999px rgba(248, 250, 252, 0.45);
      border: 2px solid var(--primary);
      pointer-events: none;
      z-index: 500;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    }

    #viewfinder.circle {
      border-radius: 9999px;
    }

    #preview-canvas {
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.12);
    }

    input[type=range] { -webkit-appearance: none; background: transparent; width: 100%; }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%;
      background: white; border: 2px solid var(--primary); margin-top: -5px;
      cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    input[type=range]::-webkit-slider-runnable-track {
      width: 100%; height: 4px; cursor: pointer; background: #e2e8f0; border-radius: 2px;
    }
  </style>
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col">
  <header class="h-14 bg-white border-b border-slate-100 flex items-center px-6 justify-between shrink-0 z-50">
    <div class="flex items-center gap-3">
      <div class="w-8 h-8 bg-slate-900 rounded-lg flex items-center justify-center text-white shadow-md">
        <i data-lucide="layers" class="w-4 h-4"></i>
      </div>
      <div>
        <h1 class="font-bold text-base tracking-tight text-slate-900 leading-none">VECTOR<span class="text-slate-400">CITY</span> TOPO</h1>
        <p class="text-[10px] text-slate-500">Interaktive Höhendaten für Print & Laser</p>
      </div>
    </div>
    <div class="flex items-center gap-3">
      <button id="back-to-map" class="hidden items-center gap-2 px-3 py-1.5 rounded-full bg-slate-900 text-white text-xs font-semibold">
        <i data-lucide="arrow-left" class="w-3 h-3"></i>
        Zurück zur Karte
      </button>
      <div class="text-[10px] uppercase tracking-[0.3em] font-semibold text-slate-400">Beta</div>
    </div>
  </header>

  <main class="flex-1 overflow-hidden">
    <div id="builder" class="flex h-full">
      <aside class="w-[380px] bg-white border-r border-slate-100 flex flex-col z-40 shadow-sm">
        <div class="flex-1 overflow-y-auto p-6 space-y-8">
          <section>
            <h2 class="text-xs font-bold text-slate-900 uppercase tracking-widest mb-4">1. Standort</h2>
            <div class="space-y-3">
              <div class="relative group">
                <i data-lucide="search" class="absolute left-3 top-3 w-4 h-4 text-slate-400"></i>
                <input type="text" id="location-search" placeholder="Ort suchen (z.B. Zürich, Bali, Tokyo)"
                  class="w-full bg-slate-50 border border-slate-200 rounded-xl py-2.5 pl-10 pr-3 text-sm font-medium focus:bg-white focus:border-blue-500 outline-none transition">
                <div id="search-results" class="absolute top-full left-0 right-0 bg-white border border-slate-100 rounded-xl mt-2 hidden z-50 max-h-60 overflow-y-auto shadow-xl p-1"></div>
              </div>
              <div class="grid grid-cols-2 gap-3">
                <div>
                  <label class="text-[10px] font-bold text-slate-500 uppercase">Format</label>
                  <select id="format-select" class="mt-2 w-full bg-slate-50 border border-slate-200 rounded-xl px-3 py-2.5 text-sm font-medium text-slate-700 focus:border-blue-500 outline-none cursor-pointer appearance-none">
                    <option value="a4-landscape">DIN A4 Quer</option>
                    <option value="a4-portrait">DIN A4 Hoch</option>
                    <option value="a3-landscape">DIN A3 Quer</option>
                    <option value="poster">Poster 2:3</option>
                    <option value="postcard">Postkarte 3:5</option>
                    <option value="square">Quadratisch 1:1</option>
                    <option value="round">Rund (Ø)</option>
                    <option value="panorama">Panorama 21:9</option>
                    <option value="landscape">Landscape 3:2</option>
                    <option value="portrait">Portrait 2:3</option>
                  </select>
                </div>
                <div>
                  <label class="text-[10px] font-bold text-slate-500 uppercase">Breite (mm)</label>
                  <input type="number" id="export-width-mm" value="210" min="80" max="1200" step="10"
                    class="mt-2 w-full bg-slate-50 border border-slate-200 rounded-xl px-3 py-2.5 text-sm font-bold text-slate-800 focus:border-blue-500 outline-none text-center">
                </div>
              </div>
              <p id="format-meta" class="text-[11px] text-slate-500">Auswahlrahmen passt sich dem Format an.</p>
            </div>
          </section>

          <section>
            <h2 class="text-xs font-bold text-slate-900 uppercase tracking-widest mb-4">2. Topografie</h2>
            <div class="space-y-4">
              <div class="bg-slate-50 border border-slate-200 rounded-xl p-3">
                <label class="text-[10px] font-bold text-slate-500 uppercase">Kontur-Abstand (m)</label>
                <input type="range" id="contour-interval" min="10" max="200" step="5" value="50" class="mt-3">
                <div class="flex justify-between text-[10px] text-slate-400 mt-2">
                  <span>Fein</span>
                  <span id="contour-value">50 m</span>
                  <span>Grob</span>
                </div>
              </div>
              <div class="grid grid-cols-2 gap-3">
                <div class="bg-slate-50 border border-slate-200 rounded-xl p-3">
                  <label class="text-[10px] font-bold text-slate-500 uppercase">Linienfarbe</label>
                  <input type="color" id="line-color" value="#111827" class="mt-3 w-full h-10 rounded-lg border border-slate-200 bg-white">
                </div>
                <div class="bg-slate-50 border border-slate-200 rounded-xl p-3">
                  <label class="text-[10px] font-bold text-slate-500 uppercase">Hintergrund</label>
                  <input type="color" id="bg-color" value="#ffffff" class="mt-3 w-full h-10 rounded-lg border border-slate-200 bg-white">
                </div>
              </div>
              <div class="bg-slate-50 border border-slate-200 rounded-xl p-3">
                <label class="text-[10px] font-bold text-slate-500 uppercase">Auflösung</label>
                <div class="mt-3 flex items-center gap-3">
                  <input type="range" id="grid-density" min="18" max="40" step="2" value="28" class="flex-1">
                  <span id="grid-label" class="text-xs font-semibold text-slate-600">28x28</span>
                </div>
                <p class="text-[10px] text-slate-400 mt-2">Mehr Punkte = mehr Details (langsamere API).</p>
              </div>
            </div>
          </section>

          <section>
            <h2 class="text-xs font-bold text-slate-900 uppercase tracking-widest mb-4">3. Export</h2>
            <button id="btn-generate" class="w-full py-3 bg-slate-900 hover:bg-slate-800 text-white font-bold text-xs rounded-xl shadow-md transition flex items-center justify-center gap-2 group">
              <i data-lucide="sparkles" class="w-4 h-4"></i>
              <span>GENERATE TOPO PREVIEW</span>
            </button>
            <div class="mt-3 text-[10px] text-slate-500">API: OpenTopoData (SRTM90m)</div>
          </section>
        </div>
      </aside>

      <div class="flex-1 relative bg-slate-100">
        <div id="map" class="w-full h-full"></div>
        <div id="viewfinder"></div>
        <div id="loader" class="absolute inset-0 bg-white/90 backdrop-blur-sm z-[1000] hidden flex-col items-center justify-center">
          <div class="animate-spin text-slate-900 mb-4"><i data-lucide="loader-2" width="48" height="48"></i></div>
          <div class="text-slate-800 text-sm font-bold uppercase tracking-widest" id="loading-text">Lade Höhendaten…</div>
          <div id="loading-sub" class="text-xs text-slate-500 mt-2">Bereite Anfrage vor</div>
        </div>
      </div>
    </div>

    <div id="preview" class="hidden h-full">
      <div class="h-full flex flex-col">
        <div class="flex-1 overflow-hidden grid grid-cols-[1.1fr_0.9fr] gap-0">
          <div class="flex items-center justify-center bg-slate-900/5">
            <canvas id="preview-canvas" width="900" height="600"></canvas>
          </div>
          <div class="bg-white border-l border-slate-100 p-8 flex flex-col">
            <div class="flex-1">
              <h2 class="font-display text-xl text-slate-900">Preview & Download</h2>
              <p class="text-sm text-slate-500 mt-2">Dein Höhenprofil ist bereit. Exportiere als PNG für Druck oder DXF für Lasergravur.</p>
              <div class="mt-6 space-y-4">
                <div class="bg-slate-50 border border-slate-200 rounded-xl p-4">
                  <div class="text-xs font-bold text-slate-500 uppercase">Projekt</div>
                  <div id="preview-meta" class="mt-2 text-sm font-semibold text-slate-800">Format · Größe · Bereich</div>
                  <div id="preview-range" class="text-xs text-slate-500 mt-1">Höhen: —</div>
                </div>
                <div class="bg-slate-50 border border-slate-200 rounded-xl p-4">
                  <div class="text-xs font-bold text-slate-500 uppercase">Tipps</div>
                  <ul class="text-xs text-slate-500 mt-2 space-y-1">
                    <li>• Für Laser: DXF in Illustrator/Inkscape öffnen.</li>
                    <li>• Für Druck: PNG mit 300 DPI im Layout platzieren.</li>
                    <li>• Runde Formate werden automatisch beschnitten.</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="space-y-3">
              <button id="download-png" class="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold rounded-xl">PNG Download</button>
              <button id="download-dxf" class="w-full py-3 bg-slate-900 hover:bg-slate-800 text-white text-xs font-bold rounded-xl">DXF Download</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    const formats = {
      'a4-landscape': { label: 'DIN A4 Quer', ratio: 1.414, shape: 'rect' },
      'a4-portrait': { label: 'DIN A4 Hoch', ratio: 1 / 1.414, shape: 'rect' },
      'a3-landscape': { label: 'DIN A3 Quer', ratio: 1.414, shape: 'rect' },
      'poster': { label: 'Poster 2:3', ratio: 2 / 3, shape: 'rect' },
      'postcard': { label: 'Postkarte 3:5', ratio: 3 / 5, shape: 'rect' },
      'square': { label: 'Quadratisch 1:1', ratio: 1, shape: 'rect' },
      'round': { label: 'Rund', ratio: 1, shape: 'circle' },
      'panorama': { label: 'Panorama 21:9', ratio: 21 / 9, shape: 'rect' },
      'landscape': { label: 'Landscape 3:2', ratio: 3 / 2, shape: 'rect' },
      'portrait': { label: 'Portrait 2:3', ratio: 2 / 3, shape: 'rect' }
    };

    const App = {
      map: null,
      state: {
        bounds: null,
        grid: [],
        min: 0,
        max: 0,
        segments: [],
        format: 'a4-landscape'
      },

      init() {
        this.map = L.map('map', { zoomControl: false, attributionControl: false, zoomSnap: 0.5 }).setView([46.948, 7.447], 13);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, subdomains: 'abcd' }).addTo(this.map);
        L.control.zoom({ position: 'topright' }).addTo(this.map);

        this.updateViewfinder();
        this.updateFormatMeta();
        this.initSearch();

        document.getElementById('format-select').addEventListener('change', (e) => {
          this.state.format = e.target.value;
          this.updateViewfinder();
          this.updateFormatMeta();
        });

        document.getElementById('grid-density').addEventListener('input', (e) => {
          document.getElementById('grid-label').textContent = `${e.target.value}x${e.target.value}`;
        });

        document.getElementById('contour-interval').addEventListener('input', (e) => {
          document.getElementById('contour-value').textContent = `${e.target.value} m`;
        });

        window.addEventListener('resize', () => this.updateViewfinder());
        document.getElementById('btn-generate').addEventListener('click', () => this.generate());
        document.getElementById('back-to-map').addEventListener('click', () => this.showBuilder());
        document.getElementById('download-png').addEventListener('click', () => this.downloadPNG());
        document.getElementById('download-dxf').addEventListener('click', () => this.downloadDXF());

        lucide.createIcons();
      },

      updateFormatMeta() {
        const format = formats[this.state.format];
        document.getElementById('format-meta').textContent = `${format.label} · Verhältnis ${format.ratio.toFixed(2)}${format.shape === 'circle' ? ' · Rund' : ''}`;
      },

      updateViewfinder() {
        const container = document.getElementById('map');
        const viewfinder = document.getElementById('viewfinder');
        const { ratio, shape } = formats[this.state.format];

        const wCont = container.clientWidth;
        const hCont = container.clientHeight;
        const margin = 90;

        let w = wCont - margin;
        let h = w / ratio;
        if (h > hCont - margin) {
          h = hCont - margin;
          w = h * ratio;
        }

        viewfinder.style.width = `${Math.round(w)}px`;
        viewfinder.style.height = `${Math.round(h)}px`;
        viewfinder.style.left = `${(wCont - w) / 2}px`;
        viewfinder.style.top = `${(hCont - h) / 2}px`;
        viewfinder.classList.toggle('circle', shape === 'circle');
      },

      getBounds() {
        const viewfinder = document.getElementById('viewfinder');
        const container = document.getElementById('map');
        const rect = viewfinder.getBoundingClientRect();
        const mapRect = container.getBoundingClientRect();
        const left = rect.left - mapRect.left;
        const top = rect.top - mapRect.top;
        const nw = this.map.containerPointToLatLng([left, top]);
        const se = this.map.containerPointToLatLng([left + rect.width, top + rect.height]);
        return { south: se.lat, west: nw.lng, north: nw.lat, east: se.lng, widthPx: rect.width, heightPx: rect.height };
      },

      async generate() {
        const loader = document.getElementById('loader');
        const loadingText = document.getElementById('loading-text');
        const loadingSub = document.getElementById('loading-sub');
        loader.classList.remove('hidden');
        loader.classList.add('flex');

        loadingText.textContent = 'Lade Höhendaten…';
        loadingSub.textContent = 'Starte API Abfrage';

        try {
          this.state.bounds = this.getBounds();
          const density = parseInt(document.getElementById('grid-density').value, 10);
          const grid = await this.fetchElevations(density, loadingSub);
          this.state.grid = grid.values;
          this.state.min = grid.min;
          this.state.max = grid.max;
          this.state.segments = this.generateContours();
          this.renderPreview();
          this.showPreview();
        } catch (error) {
          alert(`Fehler bei den Höhendaten: ${error.message}`);
        } finally {
          loader.classList.add('hidden');
          loader.classList.remove('flex');
        }
      },

      async fetchElevations(gridSize, loadingSub) {
        const bounds = this.state.bounds;
        const latStep = (bounds.north - bounds.south) / (gridSize - 1);
        const lonStep = (bounds.east - bounds.west) / (gridSize - 1);

        const points = [];
        for (let y = 0; y < gridSize; y += 1) {
          for (let x = 0; x < gridSize; x += 1) {
            const lat = bounds.south + latStep * y;
            const lon = bounds.west + lonStep * x;
            points.push({ lat, lon });
          }
        }

        const batchSize = 100;
        const values = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
        let min = Infinity;
        let max = -Infinity;

        for (let i = 0; i < points.length; i += batchSize) {
          const slice = points.slice(i, i + batchSize);
          const locations = slice.map(p => `${p.lat},${p.lon}`).join('|');
          loadingSub.textContent = `API Batch ${Math.floor(i / batchSize) + 1} / ${Math.ceil(points.length / batchSize)}`;

          const response = await fetch(`https://api.opentopodata.org/v1/srtm90m?locations=${locations}`);
          if (!response.ok) {
            throw new Error('OpenTopoData API antwortet nicht');
          }
          const data = await response.json();
          data.results.forEach((result, idx) => {
            const globalIndex = i + idx;
            const row = Math.floor(globalIndex / gridSize);
            const col = globalIndex % gridSize;
            const elevation = result.elevation ?? 0;
            values[row][col] = elevation;
            min = Math.min(min, elevation);
            max = Math.max(max, elevation);
          });
        }

        return { values, min, max };
      },

      generateContours() {
        const interval = parseInt(document.getElementById('contour-interval').value, 10);
        const { min, max, grid } = { min: this.state.min, max: this.state.max, grid: this.state.grid };
        const thresholds = [];
        const start = Math.floor(min / interval) * interval;
        for (let t = start; t <= max; t += interval) {
          thresholds.push(t);
        }

        const width = 900;
        const ratio = formats[this.state.format].ratio;
        const height = Math.round(width / ratio);

        const cols = grid[0].length;
        const rows = grid.length;
        const cellW = width / (cols - 1);
        const cellH = height / (rows - 1);
        const segments = [];

        const interpolate = (v1, v2, t) => {
          const denom = v2 - v1;
          if (denom === 0) return 0.5;
          return (t - v1) / denom;
        };

        thresholds.forEach(level => {
          for (let y = 0; y < rows - 1; y += 1) {
            for (let x = 0; x < cols - 1; x += 1) {
              const v0 = grid[y][x];
              const v1 = grid[y][x + 1];
              const v2 = grid[y + 1][x + 1];
              const v3 = grid[y + 1][x];

              let idx = 0;
              if (v0 >= level) idx |= 1;
              if (v1 >= level) idx |= 2;
              if (v2 >= level) idx |= 4;
              if (v3 >= level) idx |= 8;
              if (idx === 0 || idx === 15) continue;

              const tTop = interpolate(v0, v1, level);
              const tRight = interpolate(v1, v2, level);
              const tBottom = interpolate(v3, v2, level);
              const tLeft = interpolate(v0, v3, level);

              const points = {
                top: { x: x + tTop, y },
                right: { x: x + 1, y: y + tRight },
                bottom: { x: x + tBottom, y: y + 1 },
                left: { x, y: y + tLeft }
              };

              const addSegment = (a, b) => {
                segments.push({
                  x1: a.x * cellW,
                  y1: a.y * cellH,
                  x2: b.x * cellW,
                  y2: b.y * cellH
                });
              };

              switch (idx) {
                case 1:
                  addSegment(points.left, points.top);
                  break;
                case 2:
                  addSegment(points.top, points.right);
                  break;
                case 3:
                  addSegment(points.left, points.right);
                  break;
                case 4:
                  addSegment(points.right, points.bottom);
                  break;
                case 5:
                  addSegment(points.left, points.top);
                  addSegment(points.right, points.bottom);
                  break;
                case 6:
                  addSegment(points.top, points.bottom);
                  break;
                case 7:
                  addSegment(points.left, points.bottom);
                  break;
                case 8:
                  addSegment(points.bottom, points.left);
                  break;
                case 9:
                  addSegment(points.top, points.bottom);
                  break;
                case 10:
                  addSegment(points.top, points.right);
                  addSegment(points.bottom, points.left);
                  break;
                case 11:
                  addSegment(points.right, points.bottom);
                  break;
                case 12:
                  addSegment(points.left, points.right);
                  break;
                case 13:
                  addSegment(points.top, points.right);
                  break;
                case 14:
                  addSegment(points.left, points.top);
                  break;
                default:
                  break;
              }
            }
          }
        });

        return segments;
      },

      renderPreview() {
        const canvas = document.getElementById('preview-canvas');
        const ctx = canvas.getContext('2d');
        const ratio = formats[this.state.format].ratio;
        canvas.width = 900;
        canvas.height = Math.round(900 / ratio);

        const bg = document.getElementById('bg-color').value;
        const line = document.getElementById('line-color').value;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (formats[this.state.format].shape === 'circle') {
          ctx.save();
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2, Math.min(canvas.width, canvas.height) / 2, 0, Math.PI * 2);
          ctx.clip();
        }

        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = line;
        ctx.lineWidth = 1;
        ctx.beginPath();

        this.state.segments.forEach(seg => {
          ctx.moveTo(seg.x1, seg.y1);
          ctx.lineTo(seg.x2, seg.y2);
        });

        ctx.stroke();

        if (formats[this.state.format].shape === 'circle') {
          ctx.restore();
        }

        const widthMm = parseFloat(document.getElementById('export-width-mm').value || '0');
        const previewMeta = document.getElementById('preview-meta');
        const format = formats[this.state.format];
        previewMeta.textContent = `${format.label} · ${widthMm} mm Breite`;
        document.getElementById('preview-range').textContent = `Höhen: ${this.state.min.toFixed(0)}m – ${this.state.max.toFixed(0)}m`;
      },

      showPreview() {
        document.getElementById('builder').classList.add('hidden');
        document.getElementById('preview').classList.remove('hidden');
        document.getElementById('back-to-map').classList.remove('hidden');
      },

      showBuilder() {
        document.getElementById('builder').classList.remove('hidden');
        document.getElementById('preview').classList.add('hidden');
        document.getElementById('back-to-map').classList.add('hidden');
      },

      downloadPNG() {
        const canvas = document.getElementById('preview-canvas');
        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/png');
        link.download = 'topo-preview.png';
        link.click();
      },

      downloadDXF() {
        const widthMm = parseFloat(document.getElementById('export-width-mm').value || '0');
        const ratio = formats[this.state.format].ratio;
        const heightMm = widthMm / ratio;
        const canvas = document.getElementById('preview-canvas');

        const scaleX = widthMm / canvas.width;
        const scaleY = heightMm / canvas.height;
        const radius = Math.min(widthMm, heightMm) / 2;
        const cx = widthMm / 2;
        const cy = heightMm / 2;

        let dxf = '0\nSECTION\n2\nENTITIES\n';
        this.state.segments.forEach(seg => {
          const x1 = seg.x1 * scaleX;
          const y1 = seg.y1 * scaleY;
          const x2 = seg.x2 * scaleX;
          const y2 = seg.y2 * scaleY;

          if (formats[this.state.format].shape === 'circle') {
            const d1 = Math.hypot(x1 - cx, y1 - cy);
            const d2 = Math.hypot(x2 - cx, y2 - cy);
            if (d1 > radius || d2 > radius) return;
          }

          dxf += `0\nLINE\n8\nTOPO\n10\n${x1.toFixed(3)}\n20\n${y1.toFixed(3)}\n11\n${x2.toFixed(3)}\n21\n${y2.toFixed(3)}\n`;
        });
        dxf += '0\nENDSEC\n0\nEOF\n';

        const blob = new Blob([dxf], { type: 'application/dxf' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'topo-contours.dxf';
        link.click();
      },

      initSearch() {
        const inp = document.getElementById('location-search');
        const resDiv = document.getElementById('search-results');
        let t;
        inp.addEventListener('input', e => {
          clearTimeout(t);
          t = setTimeout(async () => {
            const q = e.target.value;
            if (q.length < 3) { resDiv.classList.add('hidden'); return; }
            try {
              const req = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
              const data = await req.json();
              resDiv.innerHTML = '';
              data.slice(0, 5).forEach(i => {
                const d = document.createElement('div');
                d.className = 'p-2 hover:bg-slate-50 cursor-pointer text-xs border-b last:border-0';
                d.textContent = i.display_name;
                d.onclick = () => {
                  this.map.setView([i.lat, i.lon], 13);
                  resDiv.classList.add('hidden');
                };
                resDiv.appendChild(d);
              });
              resDiv.classList.remove('hidden');
            } catch (err) {
              resDiv.classList.add('hidden');
            }
          }, 500);
        });
      }
    };

    window.addEventListener('load', () => App.init());
  </script>
</body>
</html>
